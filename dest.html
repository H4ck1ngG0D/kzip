<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>WAV Destroyer</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 2em;
    }
    #log {
      background: #111;
      color: #0f0;
      padding: 1em;
      margin-top: 1em;
      white-space: pre-wrap;
      font-size: 14px;
      height: 200px;
      overflow-y: auto;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <h1>ğŸ’¥ WAV çˆ†éŸ³ç ´å£Šãƒ„ãƒ¼ãƒ«</h1>
  <input type="file" id="fileInput" accept=".wav">
  <button id="processBtn">ç ´å£Šã™ã‚‹</button>
  <a id="downloadLink" style="display:none;">ğŸ”Š ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</a>
  <div id="log"></div>

  <script>
    function clamp(x, min, max) {
      return Math.max(min, Math.min(max, x));
    }

    function log(msg) {
      const logBox = document.getElementById('log');
      logBox.textContent += msg + '\n';
      logBox.scrollTop = logBox.scrollHeight;
    }

    document.getElementById('processBtn').onclick = async () => {
      const fileInput = document.getElementById('fileInput');
      const logBox = document.getElementById('log');
      logBox.textContent = ''; // clear previous logs

      if (!fileInput.files[0]) {
        log("âš ï¸ WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
        return;
      }

      try {
        log("ğŸ”„ ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ä¸­...");
        const arrayBuffer = await fileInput.files[0].arrayBuffer();
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        log("âœ… ãƒ‡ã‚³ãƒ¼ãƒ‰å®Œäº†ã€‚å‡¦ç†é–‹å§‹...");

        const numChannels = audioBuffer.numberOfChannels;
        const length = audioBuffer.length;
        const sampleRate = audioBuffer.sampleRate;
        const newBuffer = audioCtx.createBuffer(numChannels, length, sampleRate);

        for (let ch = 0; ch < numChannels; ch++) {
          const inputData = audioBuffer.getChannelData(ch);
          const outputData = newBuffer.getChannelData(ch);
          log(`ğŸšï¸ ãƒãƒ£ãƒ³ãƒãƒ« ${ch + 1} ã‚’çˆ†éŸ³å¤‰æ›ä¸­...`);

          for (let ch = 0; ch < numChannels; ch++) {
  const inputData = audioBuffer.getChannelData(ch);
  const outputData = newBuffer.getChannelData(ch);
  log(`ğŸšï¸ ãƒãƒ£ãƒ³ãƒãƒ« ${ch + 1} ã‚’çˆ†éŸ³å¤‰æ›ä¸­...`);

  for (let i = 0; i < inputData.length; i++) {
    let sample = inputData[i];

    sample *= 1e13;
    sample += (Math.random() * 2 - 1) * 1e13;

    const r = Math.random();
    if (r < 0.05) sample = -sample;
    else if (r < 0.08) sample = 0;
    else if (r < 0.10) sample *= 1e10;

    sample = Math.sign(sample) * Math.pow(Math.abs(sample), 0.5);
    outputData[i] = clamp(sample, -1, 1);
  }
}

        log("ğŸ“¦ WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ä¸­...");

        function encodeWAV(audioBuffer) {
          const numChannels = audioBuffer.numberOfChannels;
          const sampleRate = audioBuffer.sampleRate;
          const length = audioBuffer.length;
          const interleaved = new Float32Array(length * numChannels);

          for (let ch = 0; ch < numChannels; ch++) {
            const channelData = audioBuffer.getChannelData(ch);
            for (let i = 0; i < length; i++) {
              interleaved[i * numChannels + ch] = channelData[i];
            }
          }

          const buffer = new ArrayBuffer(44 + interleaved.length * 2);
          const view = new DataView(buffer);

          function writeString(offset, str) {
            for (let i = 0; i < str.length; i++) {
              view.setUint8(offset + i, str.charCodeAt(i));
            }
          }

          writeString(0, 'RIFF');
          view.setUint32(4, 36 + interleaved.length * 2, true);
          writeString(8, 'WAVE');
          writeString(12, 'fmt ');
          view.setUint32(16, 16, true);
          view.setUint16(20, 1, true);
          view.setUint16(22, numChannels, true);
          view.setUint32(24, sampleRate, true);
          view.setUint32(28, sampleRate * numChannels * 2, true);
          view.setUint16(32, numChannels * 2, true);
          view.setUint16(34, 16, true);
          writeString(36, 'data');
          view.setUint32(40, interleaved.length * 2, true);

          let offset = 44;
          for (let i = 0; i < interleaved.length; i++) {
            const s = Math.max(-1, Math.min(1, interleaved[i]));
            view.setInt16(offset, s * 32767, true);
            offset += 2;
          }

          return new Blob([view], { type: 'audio/wav' });
        }

        const wavBlob = encodeWAV(newBuffer);
        const url = URL.createObjectURL(wavBlob);
        const link = document.getElementById('downloadLink');
        link.href = url;
        link.download = 'destroyed_MAX.wav';
        link.style.display = 'inline';
        link.textContent = 'ğŸ§ å®Œå…¨ç ´å£ŠWAVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰';

        log("âœ… å®Œäº†ï¼WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å¯èƒ½ã§ã™ã€‚");
      } catch (e) {
        log("âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + e.message);
        console.error(e);
      }
    };
  </script>
</body>
</html>

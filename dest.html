<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ğŸ’¥ WAV ç ´å£Šçˆ†éŸ³ãƒ¡ãƒ¼ã‚«ãƒ¼</title>
  <style>
    body { font-family: sans-serif; padding: 2em; background: #111; color: #fff; }
    #log { background: #222; color: #0f0; padding: 1em; margin-top: 1em; white-space: pre-wrap; height: 200px; overflow-y: auto; border-radius: 8px; }
    button, input { font-size: 16px; padding: 0.5em 1em; margin-top: 1em; }
  </style>
</head>
<body>
  <h1>ğŸ’¥ WAV ç ´å£Šçˆ†éŸ³ãƒ¡ãƒ¼ã‚«ãƒ¼</h1>
  <input type="file" id="fileInput" accept=".wav">
  <button id="processBtn">ğŸ›ï¸ çˆ†éŸ³ã«ã™ã‚‹</button>
  <a id="downloadLink" style="display:none;">ğŸ”Š ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</a>
  <div id="log"></div>

  <script>
    function clamp(x, min, max) {
      return Math.max(min, Math.min(max, x));
    }

    function log(msg) {
      const logBox = document.getElementById('log');
      logBox.textContent += msg + '\n';
      logBox.scrollTop = logBox.scrollHeight;
    }

    document.getElementById('processBtn').onclick = async () => {
      const fileInput = document.getElementById('fileInput');
      const logBox = document.getElementById('log');
      logBox.textContent = '';

      if (!fileInput.files[0]) {
        log("âš ï¸ WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸ã‚“ã§ãã ã•ã„");
        return;
      }

      try {
        log("ğŸ”„ èª­ã¿è¾¼ã¿ä¸­...");
        const arrayBuffer = await fileInput.files[0].arrayBuffer();
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        log("âœ… ãƒ‡ã‚³ãƒ¼ãƒ‰å®Œäº†");

        const numChannels = audioBuffer.numberOfChannels;
        const length = audioBuffer.length;
        const sampleRate = audioBuffer.sampleRate;
        const newBuffer = audioCtx.createBuffer(numChannels, length, sampleRate);

        for (let ch = 0; ch < numChannels; ch++) {
          const inputData = audioBuffer.getChannelData(ch);
          const outputData = newBuffer.getChannelData(ch);
          log(`ğŸ”¥ ãƒãƒ£ãƒ³ãƒãƒ« ${ch + 1} çˆ†éŸ³å‡¦ç†ä¸­...`);

          for (let i = 0; i < inputData.length; i++) {
            let sample = inputData[i];

            // ğŸ”Š çˆ†éŸ³å¢—å¹…ï¼ˆå¤§ããã—ã™ããªã„ç¯„å›²ã§æœ€å¤§ï¼‰
            sample *= 1e5;

            // ğŸ’€ ãƒ›ãƒ¯ã‚¤ãƒˆãƒã‚¤ã‚º + ä½å‘¨æ³¢ãƒã‚¤ã‚º
            sample += (Math.random() * 2 - 1) * 5000;
            if (i % 100 < 50) sample *= -1; // è»½ã„æŒ¯å‹•

            // ğŸ§¨ æ­ªã¾ã›å‡¦ç†
            sample = Math.sign(sample) * Math.pow(Math.abs(sample), 0.01);

            // âš ï¸ æœ€çµ‚ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ï¼ˆFloat32ç¯„å›²ã§åˆ¶å¾¡ï¼‰
            if (isNaN(sample)) sample = 0;
            outputData[i] = clamp(sample, -1, 1);
          }
        }

        log("ğŸ“¦ æ›¸ãå‡ºã—ä¸­...");

        function encodeWAV(audioBuffer) {
          const numChannels = audioBuffer.numberOfChannels;
          const sampleRate = audioBuffer.sampleRate;
          const length = audioBuffer.length;
          const interleaved = new Float32Array(length * numChannels);

          for (let ch = 0; ch < numChannels; ch++) {
            const channelData = audioBuffer.getChannelData(ch);
            for (let i = 0; i < length; i++) {
              interleaved[i * numChannels + ch] = channelData[i];
            }
          }

          const buffer = new ArrayBuffer(44 + interleaved.length * 2);
          const view = new DataView(buffer);

          function writeString(offset, str) {
            for (let i = 0; i < str.length; i++) {
              view.setUint8(offset + i, str.charCodeAt(i));
            }
          }

          writeString(0, 'RIFF');
          view.setUint32(4, 36 + interleaved.length * 2, true);
          writeString(8, 'WAVE');
          writeString(12, 'fmt ');
          view.setUint32(16, 16, true);
          view.setUint16(20, 1, true);
          view.setUint16(22, numChannels, true);
          view.setUint32(24, sampleRate, true);
          view.setUint32(28, sampleRate * numChannels * 2, true);
          view.setUint16(32, numChannels * 2, true);
          view.setUint16(34, 16, true);
          writeString(36, 'data');
          view.setUint32(40, interleaved.length * 2, true);

          let offset = 44;
          for (let i = 0; i < interleaved.length; i++) {
            const s = clamp(interleaved[i], -1, 1);
            view.setInt16(offset, s * 32767, true);
            offset += 2;
          }

          return new Blob([view], { type: 'audio/wav' });
        }

        const wavBlob = encodeWAV(newBuffer);
        const url = URL.createObjectURL(wavBlob);
        const link = document.getElementById('downloadLink');
        link.href = url;
        link.download = 'ğŸ’¥_çˆ†éŸ³ç ´å£Š.wav';
        link.style.display = 'inline';
        link.textContent = 'ğŸ§ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰: çˆ†éŸ³å®Œæˆ';

        log("âœ… å®Œäº†ï¼");
      } catch (e) {
        log("âŒ ã‚¨ãƒ©ãƒ¼: " + e.message);
        console.error(e);
      }
    };
  </script>
</body>
</html>
